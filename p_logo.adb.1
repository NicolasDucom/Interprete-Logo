WITH Ada.Text_IO;USE Ada.Text_IO;
WITH Ada.Integer_Text_IO; USE Ada.Integer_Text_IO;
WITH Ada.Numerics; USE Ada.Numerics;
With Ada.Numerics.Elementary_Functions; USE Ada.Numerics.Elementary_Functions;
with p_fenetre; use p_fenetre;

PACKAGE BODY P_Logo IS

   procedure build(t:in out turtle; interpreterRules:in out rules; op:in out pt_command) is
   BEGIN
      Op.action:=(OTHERS=>' ');
      Op.buffer:=null;
      p_fenetre.Create_Graph_Window;
      t.orientation:=180;
      t.xCoord:=Get_window_Height/2;
      t.yCoord:=Get_window_Width/2;
      interpreterRules.penDown:=true;
   End build;
   -----------------
   -- Interpreter --
   -----------------

   PROCEDURE interpreter IS
   op:pt_command;
   interpreterRules:rules;
   turt:turtle;
   BEGIN
      Build(Turt,InterpreterRules,Op);
      While NOT compareStrings(Op.action,textToAction("exit")) LOOP
         op:=P_Logo.GetCommand;
         Put(op.action);
         Put(op.value);
         Put_line(" ");
         doCommand(Op,turt);
      END LOOP;
   END Interpreter;

   --------------------
   -- CompareStrings --
   --------------------

   FUNCTION compareStrings (
         A,
         B : t_action)
     RETURN Boolean IS
   BEGIN
      return A=B;
   END compareStrings;

   ---------------
   -- getAction --
   ---------------

   function getCommand return pt_command is
   c : character;
   op:pt_command ;
   buff:pt_buffer;
   BEGIN
      op.action:=(others=>' ');
      get(c);
      while c=' ' loop
         get(c);
      end loop;
      for i in op.action'first+1..op.action'last loop
         if c=' ' then
            exit;
         end if;
         op.action(i):=c;
         get(c);
      end loop;
      if inNoValueCommands(op.action) then
         get(op.value);
      end if;
      if inBufferCommands(op.action) then
         buff:=getBufferCommand;
         op.buffer:=buff;
      end if;
      return op;
   END getCommand ;

   function inNoValueCommands(action: t_action) return boolean is
   BEGIN
      IF compareStrings(action,textToAction("home"))
      OR compareStrings(action,textToAction("penup"))
      OR compareStrings(action,textToAction("pu"))
      OR compareStrings(action,textToAction("pendown"))
      OR compareStrings(action,textToAction("pd"))
      OR compareStrings(action,textToAction("cg"))
      OR compareStrings(action,textToAction("clean"))
      then
          return true;
      end if;
      return false;
   end inNoValueCommands;

   function inBufferCommands(action: t_action) return boolean is
   BEGIN
      if compareStrings(action,textToAction("repeat")) then
          return true;
      end if;
      return false;
   end inBufferCommands;

   function getBufferCommand return pt_buffer is
   c:character;
   Command:pt_Command;
   bufferCommand: pt_command_in_buffer;
   buffer:pt_buffer;
   BEGIN
   --buffer.first:=null;
   command.action:=(others=>'#');
   get(c);
   while c=' ' loop
      get(c);
   end loop;
   if c='[' then
         Command:=GetCommand;
         bufferCommand.command:=Command;
      while not compareStrings(command.action,textToAction("]")) loop
         addToBuffer(buffer,bufferCommand);
            Command:=GetCommand;
            bufferCommand.command:=command;
         END LOOP;
      END IF;
      return buffer;
   end getBufferCommand;

   PROCEDURE AddToBuffer(Buffer: IN OUT Pt_Buffer;Command: IN pt_command_in_buffer) IS
      NullCommand:pt_Command_In_Buffer;
      LastCommand:pt_Command_In_Buffer;
   BEGIN
   if buffer.first=nullCommand then
   buffer.first:=command;
      ELSE
         lastCommand:=LastCommandInBuffer(Buffer);
         lastCommand.nextCommand:=command;
   end if;
   buffer.length:=buffer.length+1;
   end addToBuffer;

   FUNCTION LastCommandInBuffer(Buffer:Pt_Buffer) RETURN pt_Command_In_Buffer IS
   nullCommand:pt_command_in_buffer;
   command:pt_command_in_buffer:=buffer.first;
   BEGIN
   while command.nextCommand/=nullCommand loop
      command:=command.nextCommand;
   end loop;
   return command;
   end lastCommandInBuffer;

   function endOfBuffer(buffer:Pt_Buffer;command:pt_command_in_buffer) return boolean is
   BEGIN
   return lastCommandInBuffer(buffer)=command;
   end endOfBuffer;

   function degreesToRad(d: Integer) return float is
   BEGIN
   return (Ada.Numerics.Pi*(float(d)))/float(180);
   end degreesToRad;

   function textToAction(S:in String) return t_action is
   action:t_action:=(others=>' ');
   BEGIN
      for i in S'range loop
         action(i):=S(i);
      end loop;
      return action;
   end textToAction;

   PROCEDURE put(act:in t_action) is
   BEGIN
      for i in act'range loop
         put(act(i));
      end loop;
   end put;

   procedure doCommand(comm:pt_command;turt:in out turtle) is
   BEGIN
      if compareStrings(comm.action,textToAction("forward")) OR compareStrings(comm.action,textToAction("fw")) then
         doForward(comm,turt);
      elsif compareStrings(comm.action,textToAction("backward")) OR compareStrings(comm.action,textToAction("bk")) then
         doBackward(comm,turt);
      elsif compareStrings(comm.action,textToAction("left")) OR compareStrings(comm.action,textToAction("lt")) then
         doLeft(comm,turt);
      elsif compareStrings(comm.action,textToAction("right")) OR compareStrings(comm.action,textToAction("rt")) then
         doRight(comm,turt);
      elsif compareStrings(comm.action,textToAction("repeat"))  then
         doRepeat(comm,turt);
      else
         put_line("Cette commande n'existe pas");
               end if;
    end doCommand;

   procedure doForward(comm:pt_command;turt:in out turtle) is
   oldX:integer:=turt.xCoord;
   oldY:integer:=turt.yCoord;
   BEGIN
   turt.xCoord:=turt.xCoord+integer(float(comm.value)*cos(degreesToRad(turt.orientation)));
   turt.yCoord:=turt.yCoord+integer(float(comm.value)*sin(degreesToRad(turt.orientation)));
   Draw_Line(oldY,oldX,turt.yCoord,turt.xCoord);
   end doForward;

   procedure doBackward(comm:pt_command;turt:in out turtle) is
   oldX:integer:=turt.xCoord;
   oldY:integer:=turt.yCoord;
   BEGIN
      turt.xCoord:=turt.xCoord-integer(float(comm.value)*cos(degreesToRad(turt.orientation)));
      turt.yCoord:=turt.yCoord-integer(float(comm.value)*sin(degreesToRad(turt.orientation)));
      Draw_Line(oldY,oldX,turt.yCoord,turt.xCoord);
   end doBackward;

   procedure doLeft(comm:in pt_command;turt:in out turtle)is
   BEGIN
   turt.orientation:=(turt.orientation+comm.value) mod 360;
   end doLeft;

   procedure doRight(comm:in pt_command;turt:in out turtle) is
   BEGIN
   turt.orientation:=(turt.orientation-comm.value) mod 360;
   end doRight;

   procedure doRepeat(comm:in pt_command;turt: in out turtle) IS
   BEGIN
   for i in 0..comm.value loop
      doBuffer(comm.buffer,turt);
   end loop;
   end doRepeat;

   procedure doBuffer(buffer:in Pt_Buffer;turt:in out turtle ) IS
   currentCommand:pt_command_in_buffer:=buffer.first;
   BEGIN
      doCommand(currentCommand.command,turt);
   while not endOfBuffer(buffer,currentCommand) loop
      currentCommand:=currentCommand.nextCommand;
      doCommand(currentCommand.command,turt);
   end loop;
   end doBuffer;

   END P_Logo;
